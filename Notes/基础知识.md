1. Hibernate ORM
    - JDBC: Java Database Connectivity；提供Java API访问数据库
    - ORM：Object Relational Mapping,面向对象
    - Hibernate 开源的ORM框架，将Java类映射到数据库表中，将java类型映射到SQL数据类型中，java对象和数据库表关联
    - 架构：Java Application --persistent Object-->Hibernate(Hibernate.properties, XML Mapping) --> Database 
    - 结构视图：Hibernate - Configuration, SessionFactory, Session, Transaction, Query, Criteria --> JTA/JDBC/JNDI --> Database
        - Hibernate使用不同的现存API，比如JDBC，Java 事务API（JTA）， 以及java命名和目录界面(JNDI).
        - JDBC提供了基本的抽象级别的通用关系数据库的功能，Hibernate支持几乎所有带有JDBC驱动的数据库，JNDI和JTA允许Hibernate和Java应用程序服务器集成。
    - 配置：
        - Hibernate.cfg.xml: 数据库连接
        - 类映射文件
    - 对象
        - SessionFactory:配置对象被用于创建SessionFactory，对应一个数据库，可以用于创建会话对象。线程安全且被所有线程使用。通常启动时创建。
        - Session: 会话，用于和数据库物理连接，非线程安全，不应该长时间开启。严格控制创造和销毁
        - Transaction: 事务代表一个工作单元，底层由JDBC或者JTA处理。可以不选择使用，而通过代码管理事务。
        - Query：使用SQL或HQL查询时创造的对象。用于连接查询参数，限制返回结果，并最终执行。
        - Criteria：检索对象的条件。
    - Hibernate配置属性：
        - hibernate.dialect
        - hibernate.connection.driver_class
        - hibernate.connection_url
        - hibernate.connection.username
        - hibernate.connection.password
        - hibernate.connection.pool_size
        - hibernate.connection.autocommit: JDBC连接中使用自动提交模式
        - JNDI
            - hibernate.connection.datasource
            - hibernate.jndi.class
            - hibernate.jndi.<JNDIpropertyname>
            - hibernate.jndi.url
            - hibernate.connection.username
            - hibernate.connection.password
            
    - Hibernate会话：
        - Session：和数据库的物理连接，交互时被实例化，保存持久化对象
        - 实例的三种状态：
            - 瞬时：新的实例，不和Session相关联，数据库中没有关联的记录和标识符
            - 持久状态：瞬时状态实例通过一个Session关联的方式将其转为持久化状态。在db中没有关联的记录，但是有标识符。
            - 脱管状态：关闭Hibernate Session，持久化实例将变为脱管状态实例。
        - 一般的操作：开启会话，开启事务，执行操作，提交事务，关闭事务，关闭会话。如果会话出现异常，必须回滚事务。
        - 方法：
            - beginTransaction, cancelQuery, clear, close, createCriteria, getIdentifier会话标识符，
            - createFilter, createQuery(HQL), createSQLQuery, delete, get, 
            - getSessionFactory, getTransaction, refresh(从数据库中重新读取实例状态)
            - isDirty, isOpen, isConnected, 
            - save, saveOrUpdate, update
    - 持久化类
    - 映射文件：有生成Mapping文件的工具：XDoclet, Middlegenm AndroMDA
        - class, meta, id, property, generator, column/type
        - 类型映射：映射文件中的type不是java类型，也不是SQL数据类型，如图示Hibernate映射类型，有对应关系
        - 集合映射
        - 关联映射
        - 组件映射
    - 注解：替代映射文件
        - @Entity
        - @Table 
        - @Id @GeneratedValue
        - @Column 
    - HQL：
        - 类似SQL，但是不是对表查询，而是对对象的查询，HQL在查询时翻译成SQL才被执行
        - FROM AS SELECT WHERE ORDER BY, GROUP BY 
        - 命名参数： :user_id , 然后通过query对象对这个名字设值
        - UPDATE DELETE INSERT 
        - 聚合方法： avg, count, max, min, sum
        - distinct
        - 分页：Query - setFirstResult, setMaxResults
    - 标准查询
        - Criteria - 不是通过Query对象进行查询，而是通过Criteria对象查询，是一种可编程过滤规则和逻辑条件。
        - 标准限值：Criteria - add Restrictions....
        - 分页使用标准查询：Criteria - setFirstResult(int) setMaxResults(int)
        - 排序：Order.asc(column)
        - 聚合方法：Criteria - setProjection - Projections.rowCount ... 
    - 原生SQL
        - SQLQuery 
        - 可以将SQL查询和现有的关联，addEntity addJoin addScalar
        - 标量查询，query.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP)
        - 实体查询，query.setEntity(Employee.class)
    - 缓存
        - 降低对数据库的访问频次，提高性能
        - 一级缓存：Session强制
        - 二级缓存：可选，可使用第三方缓存org.hibernate.cache.CacheProvider接口
        - 查询层次缓存，存放到物理位置，保存着查询结果和表单上次更新的时间戳，针对同一参数频繁的查询有用。
        - 很多时间是推荐关闭二级缓存
        - 使用二级缓存：并发策略，缓存到期时间和物理缓存属性。
            - 并发策略：
                - Transactional: 为主读数据使用，
                - Read-write：为主读数据再一次使用这个策略
                - Nonstrict-read-write ：不报这个缓存和数据库之间的一致性，针对数据几乎不改变或过期数据不重要
                - Read-only：适合永不改变的数据的并发策略
        - mapping - class - cache usage="read-write"
        - 缓存提供者：EHCahe, OSCache, warmCache, JBossCache, 对应支持的并发策略不一样
        - 查询层次缓存：需要配置：hibernate.cache.use_query_cache=true激活，然后query.setCacheable(true) query.setCacheRegion
    - 批处理
        - 默认的操作方式容易OutOfMemory错误，可以使用Hibernate的批处理特性，hibernate.jdbc.batch_size作为批处理的尺寸，对应每x行进行一次插入。
        - 类似与在程序中做一个计数器，每x次进行一次session.flush, session.clear;
        - session.createQuery.scroll - ScrollableResults  对应是next游标，可以边查询，边更新
    - 拦截器
        - Interceptor接口：检查持久化对象的属性，findDirty instantiate isUnsaved onDelete ...
        - Hibernate拦截器提供了对象如何应用到应用程序和数据库的总控制。
        - 比如实现一个Interceptor继承EmptyInterceptor 

2. 关系关联
    - 单向N-1关联：
        - 比如Customer - Order , 一对多的关系，Order中使用 many-to-one name=customer class=Customer column=customer_id cascade=all
        - cascade: 意味着先自动级联插入主表记录，也就是Customer记录，不建议使用该属性。
        - 多的一方是Order - many-to-one 
    - 双向1-N关联：
        - 1的一段增加集合属性，n的一段是关联实体的属性
        - 比如Customer - Order: Customer-Set<Order>; Order - Customer 
        - 集合属性要声明成接口，Hibernate的内置集合类具有集合代理功能，支持延迟检索，通过对缓存中的集合对象进行脏检查，按照集合对象的状态同步更新数据库。
        - 声明的集合实例的时候，可以实例化，避免访问的null的问题。
        - set
            - inverse属性：决定是由双向关联的哪一方来维护表和表之间的关系，true表示主动方，false是被动方，没有设置，默认都维护。
            - 1-N中，n方作为主控方将有助于性能，若1方作为主控方，会额外有很多update语句，插入时会出现非空约束问题。
            - order-by: 当查询到集合数据的时候，使用这个值排序
        - key 外建名
        - one-to-many  Customer 
    - 双向1-1关联：
        - 两边都引用关联实体的属性，比如Manager - Department , 有三种映射模式
            - 基于主键：
            - 基于外键：一方引用另一方的id
            - 使用连接表
        - 基于外键
            - 1-1关联，外键在任何一方都可以，
            - 存放外键的一方需要使用many-to-one unique=true
            - 另一端使用one-to-one 同时使用property-ref指定另一方的属性
        - 基于主键
            - 必须一段的主键生成器使用foreign策略，表明使用对方的主键来生成自己的主键，本实体不能拥有自己的主键生成策略。
            - generator class=foreign - param name property 指向对应属性作为值
            - 两边使用one-to-one映射属性，使用foreign的一端还需要增加constrained=true 属性，
            - constrained-指定为当前持久化类对应的表的主键添加一个外键约束，引用被关联对象所对应的数据库主键
    - N-N关联：
        - 增加一张表才能完成映射
        - 比如Category和Item，每个条目有多个类别，一个类别有多个条目。使用many-to-many,属性是set
        - 两边都必须指定表名和外键列名，双向的n-n关联，必须把其中一端的inverse设置为true，否则两端都维护关联关系，可能造成主键冲突。

3. HQL
    - 功能：
        - 设置查询条件
        - 投影查询，仅检索部分属性
        - 分页查询
        - 连接查询
        - 分组查询，允许使用HAVING和Group by 关键字
        - 内聚函数，sum min max
        - 支持子查询
        - 支持动态绑定参数
        - 调用用户定义的SQL函数或标准的SQL函数
    - HQL vs SQL
        - HQL面向对象，SQL是和数据库绑定在一起的
    - 实体查询
        - from User, 本身大小写无关，但是类名和属性名大小写要注意。
        - 如果查询的实体User有子类，那么上面的查询会查询到两个子类的数据，即使他们在不同的表中。
        - AS 可省略，WHERE  = < > >= between not between in not in  is like 或者里面有算数运算表达式
    - 属性查询
        - SELECT 每个结果都是Object[] 
    - 实体更新与删除
        - HQL的更新和删除对应比操作要好很多，但是要注意对缓存策略的影响，很可能造成同步的障碍。
    - 分组和排序
        - order by
        - group by 
        - 参数绑定： 因为SQL注入的原因，要使用参数的方式:user_ids。
    - 引用查询
        - 有些编码规范：代码中不允许出现sql语句。代码中混杂SQL会破坏代码的可读性，降低可维护性，所以通常采用SQL配置化的方式，SQL保存到配置文件中
        - HQL可配置化：在实体映射文件中，通过query节点定义查询语句  `<query name="queryTest"><![CDATA[FROM User user where user.uAge < 20]]></query>`
        - 通过session.getNamedQuery(""name")
        - 关联查询
            - 迫切左外连接 left join fetch 去重的问题 distinct或者hashSet
            - 左外连接  left join 根据配置文件决定集合的检索策略，比如是fetch, lazy等，还是像上面一样
            - 使用的时候，推荐使用迫切左外连接，因为迫切左外连接只发送一条sql语句就可以查出来，而左外连接还会进行查询，性能上迫切左外连接要好。
        - 子查询
            - 子查询必须出现在where子句中，且必须使用圆括号包围。
4. 检索策略
    - 检索查询的两个问题
        - 不浪费内存：比如Customer 和 Order是双向1-N关联，当加载Customer时，如果同时加载Order对象，就浪费很多内存
        - 更高的查询效率：发送尽可能少的SQL语句
    - 类级别的检索策略
        - 立即检索
        - 延迟检索
        - lazy属性：
            - 注意LazyInitializationException:在使用延迟加载时，并没有将数据查询出来，而是得到了一个代理对象，当使用属性时才会去查询，但是session已经关闭了。
            - class上设置lazy=false - 立即检索
            - 无论元素的lazy属性时true还是false，Session的get方法及Query的list方法在类级别总是使用立即检索策略
            - 若lazy的属性为true或默认值，Session.load方法不会执行查询数据表的select语句，仅返回代理对象的实例，
            - 代理对象是由Hibernate在运行时采用CGLIB工具动态生成。创建时值由OID属性，在应用程序第一次访问代理类实例的非OID属性时，会初始化代理类实例。
    - 1-N N-N的检索策略
        - lazy 决定集合被初始化的时机，是在加载的时候就初始化，还是访问集合的时候初始化。
        - fetch select subselect，决定初始化的查询语句形式，join，决定集合被初始化的时机。
        - fetch=join时，lazy属性被忽略
        - batch-size，设定延迟检索策略或立即检索策略的批量数量，是减少select语句的数目，提高延迟检索或立即检索的运行性能。
        - 延迟加载，当应用程序第一次访问集合属性iterator size isEmpty contains方法，或者使用Hibernate.initialize()显式初始化
        - lazy extra 类似与true，但是是尽可能的延迟初始化的时机，比如取size的使用只用count语句，
    - N-1 1-1的检索策略
        -  这里也有对应的设置
    - 三种检索策略比较
        - 立即检索
            - 优点：对应用程序完全透明，无论对象处于持久化状态还是游离状态（session是否关闭），应用程序可以方便的从一个对象导航到与它相关的对象。
            - 缺点：select语句数目多，可能会加载应用程序不需要访问的对象，白白浪费内存空间。
            - 优先考虑的场合：(1)类级别；(2)应用程序需要立即访问的对象；(3)使用了二级缓存
        - 延迟检索
            - 优点：由应用程序决定需要加载哪些对象，可以避免执行多余的select语句，以及避免加载应用程序不需要访问的对象。因此能提高检索性能，并且节省内存空间。
            - 缺点：应用程序如果希望访问游离状态的代理类实例，必须保证它在持久化状态已经被初始化。
            - 优先考虑的场合：(1)1-N关联或者N-N关联；(2)应用程序不需要立即访问或者根本不会访问的对象
        - 迫切左外连接检索
            - 优点：对应用程序完全透明，不管对象处于持久状态，还是游离状态，应用程序可以方便的从一个对象导航到与它相关的对象。
            - 缺点：可能会加载应用程序不需要访问的对象，白白浪费内存空间；复杂的数据库表连接也会影响检索性能。
            - 优先考虑的场合：(1)N-1或者N-N关联；(2)应用程序需要立即访问的对象；(3)数据库具有良好的表连接性能。

5. 缓存机制
    - 当使用1-N这种关系，查询过程就有可能出现N+1的问题，这个会造成SQL语句的增加
    - 什么样的数据放入缓存：
        - 很少修改
        - 不是很重要的，允许出现偶尔并发
        - 不会被并发访问的
        - 常量数据
    - 什么样的数据不会放入内存
        - 经常修改
        - 绝对不允许出现并发访问的数据，如财务数据
        - 与其他应用共享的数据
    - 一级缓存
        - 事务级别的，每个事务都有单独的一级缓存，由Hibernate进行管理
        - 每个事务都拥有单独的一级缓存，不会出现并发问题，因此无需提供并发访问策略
        - 当应用程序调用session save update saveOrUpdate get load list 
            
            
        
        
                
        
        
        
        